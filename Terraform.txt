# Providers allow Terraform to interact with cloud providers, SaaS providers, and other APIs.The providers are specified in the Terraform configuration code. They tell Terraform which services it needs to interact with
# Terraform workspaces - Terraform workspaces associated with a specific working directory and isolate multiple state files of multiple stages in the same working directory, 
  it will create state file per environment such as Dev, test, prod. So, our state file will not be overlapping and we don’t need to create terraform project again and again we can use same terraform project . 
  There is no problem in conflicting infrastructure.
# 
Afer terraform init>>    1) .terraform 2) .terraform.lock.hcl

Afer terraform plan>> nothing file to create

Afer terraform apply>>  1) terraform.tfstate 2) terraform.tfstate.backup

# What Is Terraform Lock FIle Or Terraform: Dependency Lock File (.terraform.lock.hcl)

The terraform lock file is named “Terraform. lock.hcl” It will generated by the terraform itself and it will make sure that the same infrastructure will be created if multiple users are working. It is used by Terraform to track the desired state of our infrastructure.

Terraform Lock file is a file that helps to prevent multiple users or processes from simultaneously making changes to same infrastructure. Lock file is used to locking the state file during update , preventing any other users or processes then modifying the infrastructure in the same time. this ensures only one user or process can make changes to the infrastructure at same time 

If multiple users or processes attempts to modify the infrastructure in the same time then it can cause conflict and lead to un expected behaviours


# Terraform local variable-
In a local variable, you can use dynamic expressions means it can be manipulated it is a thing that you cannot do with input variables but later then we can refer to terraform input variables
Local variables are blocks of code within Terraform that allow us to store data that we might want to refer to at a terraform input variable

Local variables are declared using the localsblock. It is a group of key-value pairs that can be used in the configuration. The values can be hard-coded or be a reference to another variable or resource.
Local variables are accessible within the module/configuration where they are declared. Let us take an example of creating a configuration for an EC2 instance using local variables. Add this to a file named main.tf.
locals {
ami  = "ami-0d26eb3972b7f8c96"
type = "t2.micro"
tags = {
Name = "My Virtual Machine"
Env  = "Dev"
}
subnet = "subnet-76a8163a"
nic    = aws_network_interface.my_nic.id
}
resource "aws_instance" "myvm" {
ami           = local.ami
instance_type = local.type
tags          = local.tags
network_interface {
network_interface_id = aws_network_interface.my_nic.id
  device_index         = 0
}
}
resource "aws_network_interface" "my_nic" {
description = "My NIC"
subnet_id   = var.subnet
tags = {
Name = "My NIC"
}
}


# Meta Argument in terraform:-Meta-arguments are special arguments in Terraform that are used to control how resources are created, updated, or destroyed. 
They are not specific to any particular resource type, but rather provide a way to configure behavior across all resources in a Terraform configuration.
Terraform supports the following meta-arguments:
• depends_on.
• count.
• for_each.
• provider.
• lifecycle.
• provisioner.
# Terraform show   to see the state file

# Terraform Provisioners are used for executing scripts or shell commands on a local or remote machine as part of resource creation/deletion. 
They are similar to “EC2 instance user data” scripts that only run once on the creation and if it fails terraform marks it tainted-

1. **file Provisioner:**
  The `file` provisioner is used to copy files or directories from the local machine to a remote machine. This is useful for deploying configuration files, scripts, or other assets to a provisioned instance.
  Example:
  ```hcl
  resource "aws_instance" "example" {
    ami           = "ami-0c55b159cbfafe1f0"
    instance_type = "t2.micro"
  }
  provisioner "file" {
    source      = "local/path/to/localfile.txt"
    destination = "/path/on/remote/instance/file.txt"
    connection {
      type     = "ssh"
      user     = "ec2-user"
      private_key = file("~/.ssh/id_rsa")
    }
  }
  ```
  In this example, the `file` provisioner copies the `localfile.txt` from the local machine to the `/path/on/remote/instance/file.txt` location on the AWS EC2 instance using an SSH connection.
2. **remote-exec Provisioner:**
  The `remote-exec` provisioner is used to run scripts or commands on a remote machine over SSH or WinRM connections. It's often used to configure or install software on provisioned instances.
  Example:
  ```hcl
  resource "aws_instance" "example" {
    ami           = "ami-0c55b159cbfafe1f0"
    instance_type = "t2.micro"
  }
  provisioner "remote-exec" {
    inline = [
      "sudo yum update -y",
      "sudo yum install -y httpd",
      "sudo systemctl start httpd",
    ]
    connection {
      type        = "ssh"
      user        = "ec2-user"
      private_key = file("~/.ssh/id_rsa")
      host        = aws_instance.example.public_ip
    }
  }
  ```
  In this example, the `remote-exec` provisioner connects to the AWS EC2 instance using SSH and runs a series of commands to update the package repositories, install Apache HTTP Server, and start the HTTP server.
3. **local-exec Provisioner:**
  The `local-exec` provisioner is used to run scripts or commands locally on the machine where Terraform is executed. It is useful for tasks that don't require remote execution, such as initializing a local database or configuring local resources.
  Example:
  ```hcl
  resource "null_resource" "example" {
    triggers = {
      always_run = "${timestamp()}"
    }
    provisioner "local-exec" {
      command = "echo 'This is a local command'"
    }
  }
  ```
  In this example, a `null_resource` is used with a `local-exec` provisioner to run a simple local command that echoes a message to the console whenever Terraform is applied or refreshed. The `timestamp()` function ensures it runs each time.
OR another example for local provisioner-
resource "aws_instance" "web" {
 # ...
 provisioner "local-exec" {
   command = "echo ${self.private_ip} >> private_ips.txt"
 }
}









